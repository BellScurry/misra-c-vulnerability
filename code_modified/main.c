#include "susan.h"
#include <stdio.h>

/** MISRA C **/
void main(int argc, char *argv[]) {

    FILE   *ofp;
    char   filename [80], *tcp;
    unsigned char *in, *mid;
    unsigned char buff[516];
    unsigned char *buffptr = buff;
    float  dt=4.0;
    int    *r,
           argindex=3,
           bt=20,
           principle=0,
           thin_post_proc=1,
           three_by_three=0,
           drawing_mode=0,
           susan_quick=0,
           max_no_corners=1850,
           max_no_edges=2650,
           mode = 0, 
           i,
           x_size, 
           y_size;

    CORNER_LIST corner_list;
    
    if (argc<3)
        usage();

    misrac_get_image(argv[1],&in,&x_size,&y_size);

    //    Look at options.
    while (argindex < argc) {
 
        tcp = argv[argindex];

        if (*tcp == '-') {
            switch (*++tcp) {
     
                case 's':   //  Smoothing
                    mode=0;
                    break;
    
                case 'e':   //  Edges
                    mode=1;
                    break;

                case 'c':   //  Corners
                    mode=2;
                    break;

                case 'p':   //  Principle
                    principle=1;
                    break;

                case 'n':   //  Thinning post processing
                    thin_post_proc=0;
                    break;

                case 'b':   //  Simple drawing mode
                    drawing_mode=1;
                    break;

                case '3':   //  3x3 flat mask
                    three_by_three=1;
                    break;

                case 'q':   //  Quick susan mask
                    susan_quick=1;
                    break;

                case 'd':       //  Distance threshold
                    if (++argindex >= argc) {
                        
                        printf ("No argument following -d\n");
                        exit(0);
                    }
                    dt=atof(argv[argindex]);
     
                    if (dt<0)
                        three_by_three=1;

                    break;

                case 't':       //  Brightness threshold
                    if (++argindex >= argc){

                        printf ("No argument following -t\n");
                        exit(0);
                    }

                    bt=atoi(argv[argindex]);
                    break;
            }	
        }
        else
            usage();
        
        argindex++;
    }

    if ( (principle==1) && (mode==0) )
        mode=1;

    //    Main Processing
    switch (mode) {

        case 0:
            //    Smoothing
            misrac_setup_brightness_lut(&buffptr,bt,2);
            misrac_susan_smoothing(three_by_three,in,dt,x_size,y_size,buffptr);
            break;

        case 1:
            //    Edges
            r   = (int *) malloc(x_size * y_size * sizeof(int));
            misrac_setup_brightness_lut(&buffptr,bt,6);

            if (principle) {

                if (three_by_three)
                    susan_principle_small(in,r,buffptr,max_no_edges,x_size,y_size);
                else
                    susan_principle(in,r,buffptr,max_no_edges,x_size,y_size);
                
                int_to_uchar(r,in,x_size*y_size);
            }
            else {

                mid = (unsigned char *)malloc(x_size*y_size);
                memset (mid,100,x_size * y_size);       //  Note not set to zero

                if (three_by_three)
                    susan_edges_small(in,r,mid,buffptr,max_no_edges,x_size,y_size);
                else
                    susan_edges(in,r,mid,buffptr,max_no_edges,x_size,y_size);
                
                if(thin_post_proc)
                    susan_thin(r,mid,x_size,y_size);

                edge_draw(in,mid,x_size,y_size,drawing_mode);
     
            }
            break;

        case 2:
            //    Corners
            r   = (int *) malloc(x_size * y_size * sizeof(int));
            misrac_setup_brightness_lut(&buffptr,bt,6);

            if (principle) {

                susan_principle(in,r,buffptr,max_no_corners,x_size,y_size);
                int_to_uchar(r,in,x_size*y_size);
            }
            else {

                if(susan_quick)
                    susan_corners_quick(in,r,buffptr,max_no_corners,corner_list,x_size,y_size);
                else
                    misrac_susan_corners(in,r,buffptr,max_no_corners,corner_list,x_size,y_size);

                corner_draw(in,corner_list,x_size,drawing_mode);
            }
            break;
    }    

    put_image(argv[2],in,x_size,y_size);
}
