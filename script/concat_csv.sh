#!/bin/bash

# Usage: _is_number <number>
#
#   If the given string is number, echo 'true'.
#   Else, echo null
_is_number() {

    echo $1 | sed 's/^[0-9]\+\(\.[0-9]\+\)\?$/true/g'
}

# Usage: _find_word_in <word> <file>
#
#   Find the given word in the file.
#   If found, echo 'true'.
#   If not found, echo 'false'
_find_word_in() {

    result=$(sed -n "/$1/p" $2)

    if [[ -n "$result" ]]; then
        # Success: Found
        echo true
        return 0
    else
        # Fail: Not Found
        echo false
        return 1
    fi
}

# Usage: _concat_two_csv <file1> <file2> <diff option>
#
#   Concat the two given csv files, then echo result.
#   If diff option is given 'true',
#   then calculate diff ratio
_concat_two_csv() {

    linenum=0
    linediff=0

    while IFS= read -r line || [[ -n $line ]];
    do
        linenum=$((linenum + 1))

        # Skip key comparison, assuming the two files have exactly same keys.
        first_key_value=$(sed -n "${linenum}p" < $1)
        first_key=$(echo $first_key_value | sed 's/\([^,]*\),.*/\1/')
        first_value=$(echo $first_key_value | sed "s/[^,]*,[[:space:]]*\([^,[:space:]]*\).*/\1/g")

        # Use pipe to get line# before pattern matching.
        # For example, with
        #    key=$(sed -n "s/^\([^,]*\),\+.*$/\1/${linenum}p" < $1)
        # GNU sed will give line# after pattern matching.
        second_key=$(sed -n "$((linenum + linediff))p" < $2 | sed 's/\([^,]*\),.*/\1/')
        second_value=$(sed -n "$((linenum + linediff))p" < $2 | sed -e "s/[^,]*,[[:space:]]*\([^,[:space:]]*\).*/\1/")
        
        diff_string=""

        if [[   "$3" = true &&
                "$first_key" = "$second_key" &&
                $(_is_number "$first_value") = true &&
                $(_is_number "$second_value") = true &&
                "$first_value" != "0" ]]; then
        
            # Caculate Ratio: (even/odd - 1) * 100 (%)
            diff_ratio=$(echo $first_value $second_value | awk '{ printf "%.2f", (($2/$1)-1)*100 }')"%"
            diff_string=", ${diff_ratio}"  
        else
            if [[ "$(_find_word_in $first_key $2)" = true ]]; then
                linediff=$((linediff + 1))
            else
                linediff=$((linediff - 1))
            fi
        fi

        echo "${first_key_value}, ${second_value}""${diff_string}"

    done < $1
}

# Usage: concat_csv [options] <files>
#    or: concat_csv <files> [options] <files>
#    or: concat_csv <files> [options]
#
#   Concatenate contents of given csv files
#
# ASSUMPTION
#
#   The given files have keys in same order
#
# Options
#
#   --diff: Print diff ratio
#
# Implementation
#
#   By using subfunctions: _is_number()
#                          _find_word_in()
#                          _concat_two_csv()
concat_csv() {

    # Flag Initialization
    print_diff=false
    
    # Array Initialization
    file_list=()

    # Variable Initialization
    file_count=0
    prev_file=""
    file=""

    for arg in "$@"
    do
        case $arg in 
            --diff)
                print_diff=true
                ;;
            -*)
                ;;
            *)
                file_count=$((file_count + 1))
                file_list[$file_count]=${arg}
                ;;
        esac
    done
 
    tmp1=$(mktemp)
    tmp2=$(mktemp)
    first=true

    # For faster script speed when only two files
    if [[ "$file_count" -eq 2 ]]; then
        _concat_two_csv ${file_list[1]} ${file_list[2]} $print_diff
        return 0
    fi

    for cur_file in "${file_list[@]}"
    do
        if [[ "$first" = true ]]; then
            cat ${file_list[1]} > $tmp1
            first=false
        else
            _concat_two_csv $tmp1 $cur_file $print_diff > $tmp2
            cat $tmp2 > $tmp1
        fi
    done

    # Echo the result
    cat $tmp2

    rm $tmp1 $tmp2
}
