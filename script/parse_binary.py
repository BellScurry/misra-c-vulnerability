import sys
import re


def branch_inst_digest(line):
    # Return (inst_addr, branch_dest_addr)
    # Elements in returned tuple are decimal
    # e.g. 8e80:   ea000017    b   8ee4 <main+0x1d8>
    #       -> return ("8e80", "8ee4")
    l = line.split()
    if not ARM_SECOND_HEX.get(l[1][1]):
        return None

    tmplist = list(l[0])
    del tmplist[-1]
    inst_addr = "".join(tmplist)

    return (int(inst_addr, 16), int(l[3], 16))


RE_MAIN = re.compile(r".*<main>.*")
ARM_SECOND_HEX = {
    'a':'Branch',
    'b':'Branch with Link'
}
label_addr = []
bid = []
armcode = []
infile = open(sys.argv[1], 'r')
flag_main = False

# Get subroutine <main>
#
#   ARM Assebly File Format
#   - line.split()[0]: Address
#   - line.split()[1]: Instruction (hex)
#   - line.split()[2:]: Human-readable instruction & Comment
for line in infile.readlines():
    if flag_main:
        if not line.strip():
            break
        lastline = line
        branch = ARM_SECOND_HEX.get(line.split()[1][1])
        if branch:
            # Push (inst_addr, branch_dest_addr)
            bid.append(branch_inst_digest(line))
            
            # Push branch destination address in decimal,
            # because we will easily calculate offset
            #
            # We get line.split()[3] as destination address
            #   e.g. 8e80:   ea000017    b   8ee4 <main+0x1d8>
            #   e.g. 8e50:   baffffed    blt 8e0c <main+0x100>
            label_addr.append(int(line.split()[3], 16))

            line = line.rstrip() + " " * 24 + "# " + branch + "\n"
        armcode.append(line)
    elif RE_MAIN.match(line):
        armcode.append(line)
        # Store start address of <main> subroutine in decimal,
        # because we will easily calculate offset
        #
        # We can get start address like:
        #   e.g. 00008d0c <main>:
        start_addr = int(line.split()[0], 16)
        flag_main = True


infile.close()
# Remove last character in lastline.split()[0]
#   e.g. 00008d0c <main>:
tmplist = list(lastline.split()[0])
del tmplist[-1]
end_addr = int("".join(tmplist), 16)

# Remove duplicates in 'label_addr', then sort
label_addr = list(set(label_addr))
label_addr.sort()

# Remove label destination addresses which points to subroutines
#   e.g. 8d40: eb001f16    bl  109a0 <_IO_fwrite>
trash_index = None
for addr in label_addr:
    if addr > end_addr:
        trash_index = label_addr.index(addr)
        break

if trash_index:
    del label_addr[trash_index:]
# Label destination addresses
for digest in bid:
    dest_addr = digest[1]
    if dest_addr <= end_addr:
        idx = (digest[0] - start_addr) // 4 + 1
        oldline = armcode[idx]
        del armcode[idx]
        newline = oldline.rstrip() + " to L" + str(label_addr.index(digest[1]) + 1) + "\n"
        armcode.insert(idx, newline)

# Insert labels into assembly
#   e.g. L1:
for i in range(0, len(label_addr)):
    offset = label_addr[i] - start_addr
    armcode.insert((offset // 4 + 1 + i), "L" + str(i+1) + ":\n")


outfile = open(sys.argv[2], 'w')
outfile.write("".join(armcode))
outfile.close()
