import os.path
import sys
import argparse
import glob
import subprocess
import re
import textwrap
import collections


# Debug Class Method
def debug(f):
    msg = f.__name__
    def wrapper(*args):
        print(msg)
        return f(*args)
    return wrapper

# Debug Class Instance
def debug_object(obj):
    print('{:<24}'.format('DEBUGGING'), obj.__class__, obj)
    for attr in vars(obj):
        prefix = attr
        message = str(obj.__dict__.get(attr))
        wrapper = textwrap.TextWrapper(width=75, initial_indent='{:<25}'.format(prefix), subsequent_indent=' '*25)
        print(wrapper.fill(message))

class GemvRunner:
    # Static Constants
    RE_SHELLVAR  = re.compile(r'\$[a-zA-Z_]+[a-zA-Z0-9_]*')
    RE_CONFIGNUM = re.compile(r'config(\d+).csv')
    RE_WLNUM     = re.compile(r'workload(\d+).csv')

    # Instance Variables
    #  - PROJECT_HOME
    #      (ex) /home/ubuntu/misra-c-vulnerability
    #  - GEMV_HOME
    #      (ex) /home/ubuntu/GemV-2.0/gemV
    #  - GEMV_BINARY
    #      (ex) /home/ubuntu/GemV-2.0/gemV/build/ARM/gem5.opt
    #  - GEMVSCRIPT
    #      (ex) /home/ubuntu/GemV-2.0/gemV/configs/example/se.py
    #  - PATH_ALIAS
    #      (ex) $GEMV_HOME, /home/ubuntu/GemV-2.0/gemV
    #  - GEMV_CONFIG_LIST
    #      (ex) {
    #              1:'--caches --l1d=8kB --l1i=4kB',
    #              2:'--caches --l1d=4kB --l1i=4kB'
    #           }
    #
    #  - _cache_wlinfo
    #  - _cache_bench_name
    #  - _cache_output_home


    def __init__(self):
        # Initialize:
        #  - PROJECT_HOME
        self.PROJECT_HOME=os.path.abspath(os.path.dirname(os.path.realpath(__file__)) + '/..')

        # Initialize:
        #  - PATH_ALIAS
        #  - GEMV_CONFIG_LIST
        
        #   Pseudo-declaration of PATH_ALIAS
        self.PATH_ALIAS = {}

        #   Read <project home>/config/Pathinfo.csv and
        #   <project home>/config/Baseline.csv
        with open(self.PROJECT_HOME + '/config/Pathinfo.csv', 'r') as tmp:
            self.csv_to_option(tmp)
        with open(self.PROJECT_HOME + '/config/Baseline.csv', 'r') as tmp:
            gemv_baseline_config = self.csv_to_option(tmp)

        # We assume there is GEMV_HOME in <prject home>/config/Pathinfo.csv
        # Initialize:
        #  - GEMV_HOME
        #  - GEMV_BINARY
        #  - GEMVSCRIPT
        self.GEMV_HOME = self.PATH_ALIAS['GEMV_HOME']
        self.GEMV_BINARY = self.GEMV_HOME + '/build/ARM/gem5.opt'
        self.GEMVSCRIPT = self.GEMV_HOME + '/configs/example/se.py'

        #   gemV Script Options into a OrderedDict 'GEMV_CONFIG_LIST'
        tmpdict = {}
        for c in glob.glob(self.PROJECT_HOME + '/config/config*.csv'):
            configfile = os.path.basename(c)
            confignum = GemvRunner.RE_CONFIGNUM.search(configfile).group(1)
            with open(self.PROJECT_HOME + '/config/config' + confignum + '.csv', 'r') as tmp:
                script_option = ' '.join([gemv_baseline_config, self.csv_to_option(tmp)])
            tmpdict[confignum] = script_option

        self.GEMV_CONFIG_LIST = collections.OrderedDict(sorted(tmpdict.items(), key=lambda e: int(e[0])))

    #@debug
    def csv_to_option(self, csvfile):
    # This method process five cases such that:
    #  1. Transform a csv line to shell option
    #       (ex) caches     ->   '--caches'
    #  2. Transform a csv line to key-value shell option
    #       (ex) l1d, 4kB   ->   '--l1d=4kB'
    #  3. Store PATH ALIAS
    #       (ex) $SRC_HOME, /home/ubuntu/misra-c-vulnerability/src
    #  4. Load PATH ALIAS and transform a csv line
    #     to key-value shell option
    #       (ex) option, $SRC_HOME/escape/workload/input1.txt
    #  5. Load a PATH ALIAS and store another PATH ALIAS
    #       (ex) $ESCAPE_HOME, $SRC_HOME/escape
    #  Note that
    #    Case 4 = Load PATH ALIAS + Case 2
    #    Case 5 = Load PATH ALIAS + Case 3

        config = ''
        tmp = []
        for line in csvfile:
            word = line.replace(',', '').strip().split()
         
            # Note that len(word) is 1 in case 1,
            # larger that 1 in the other cases
            if len(word) == 1:
                # Case 1
                tmp.append('--' + word[0])
            elif len(word) > 1:
                load_path_alias = GemvRunner.RE_SHELLVAR.search(word[1])
                if load_path_alias:
                    key = load_path_alias.group(0)
                    value = self.PATH_ALIAS.get(key[1:])
                    if not value:
                        print('ERROR:', key, 'NOT FOUND', file=sys.stderr)
                    second_word = word[1].replace(key, value)
                else:
                    second_word = word[1]

                store_path_alias = GemvRunner.RE_SHELLVAR.search(word[0])
                if not store_path_alias:
                    # Case 2
                    tmp.append('--' + word[0] + '=' + second_word)
                else:
                    # Case 3
                    key = word[0][1:]
                    self.PATH_ALIAS[key] = second_word
            else:
                pass

        config = ' '.join(tmp)
        return config 

    
    def run(self, wlinfo_path):
        self._run_simulation(wlinfo_path)
        #TODO:self._gen_digest()


    #@debug
    def _run_simulation(self, wlinfo_path):
        # Add PATH_ALIAS if it exist:
        #   Apply <benchmark home>/workload_info/Pathinfo.csv
        pathinfo = os.path.abspath(wlinfo_path + '/Pathinfo.csv')
        if os.path.isfile(pathinfo):
            with open(pathinfo, 'r') as tmp:
                self.csv_to_option(tmp)

        # Prepare list of workloads:
        #   Read <benchmark home>/workload_info/workloadN.csv,
        #   then do the simulation
        tmpdict = {}
        for infofile in glob.glob(wlinfo_path + '/workload*.csv'):
            with open(infofile, 'r') as tmp:
                wlnum = GemvRunner.RE_WLNUM.search(infofile).group(1)
                tmpdict[wlnum] = self.csv_to_option(tmp)

        self._cache_wlinfo = collections.OrderedDict(sorted(tmpdict.items(), key=lambda e: int(e[0])))

        # Simulation Output Path & Benchmark Name
        bench_home = os.path.abspath(wlinfo_path + '/..')
        self._cache_bench_name = os.path.basename(bench_home)
        self._cache_output_home = os.path.abspath(bench_home + '/output_' + self._cache_bench_name)

        # Run Simulation with Various Configurations & Workloads
        for confignum in self.GEMV_CONFIG_LIST:
            for wlnum in self._cache_wlinfo:
                # Output directory: output/configM/workloadN
                gemv_option = ''.join(['-re --outdir=', self._cache_output_home,
                                       '/config', confignum,
                                       '/workload', wlnum])
                gemvscript_option = ' '.join([self.GEMV_CONFIG_LIST[confignum], self._cache_wlinfo[wlnum]])

                # Concat strings to make gemV command:
                #   <GEMV_BINARY> <GEMV_OPTION> <GEMVSCRIPT> <GEMVSCRIPT_OPTION>
                cmd = ' '.join([self.GEMV_BINARY, gemv_option, self.GEMVSCRIPT, gemvscript_option])

                # Run gemV command
                subprocess.call(cmd, shell=True)


    def _gen_digest(self):
        # Post Process
        # TODO: Apply <bench home>/workload_info/Group.csv
        # TODO: Apply <prj home>/config/Digest.csv
        for confignum in self.GEMV_CONFIG_LIST:
            for wlnum in self._cache_wlinfo:
                pass



if __name__ == '__main__':
    if len(sys.argv) > 1:
        runner = GemvRunner()
        runner.run(sys.argv[1])
    else:
        print('ERROR: Too less argument', file=sys.stderr)
